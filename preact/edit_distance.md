# 前言
继上一篇，我们谈到，需要一个较为完善的虚拟DOM diff 算法，以提高DOM更新的性能。
这方面，已有两篇文章写得非常棒，参考：
1. http://efe.baidu.com/blog/the-inner-workings-of-virtual-dom/
2. https://github.com/livoras/blog/issues/13

珠玉在前，我便不再赘述。因此，本文我们来关注因此引申出来的问题：列表对比算法。

> 现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。
这个问题抽象出来其实是字符串的最小编辑距离问题（Edition Distance），
最常见的解决算法是 Levenshtein Distance，通过动态规划求解，时间复杂度为 O(M * N)。
但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，
牺牲一定DOM操作，让算法时间复杂度达到线性的（O(max(M, N))。

因此，今天我们来求解最小编辑距离。

# 问题
给定两个字符串 a 和 b，
只允许以下三种操作：
1. 替换一个字符
2. 删除一个字符
3. 插入一个字符

求：把字符串 a 变换成 字符串 b 的最小操作次数，也就是所谓的最小编辑距离。
举例，"ab" => "ac"，只需要把b替换成c，因此最小编辑距离为1
"acd" => "abd"，需要插入b、删除c，因此最小编辑距离为2

这个问题的求解有两种思路：递归和动态规划

# 递归
所谓递归，就是把大的问题化解为相似的小问题。
假设a的长度是m，b的长度是n。
我们要求解 a[1]a[2]...a[m] => b[1]b[2]...b[n] 的最小编辑距离，记号为d[m][n]
如果 a[m] === b[n]，那么问题转化为 a[1]a[2]...a[m-1] => b[1]b[2]...b[n-1]，也就是 d[m][n] === d[m-1]b[n-1]
如果 a[m] !== b[n]，要想把 a 转换为 b，又分为三种情况
1. 直接把 a[m] 换成 b[n]，也就是 d[m][n] === d[m-1][n-1] + 1
1. 在 a[1]a[2]...a[m-1] 的基础上，插入 a[m]，也就是 d[m][n] === d[m-1][n] + 1
2. 在 b[1]b[2]...b[n-1] 的基础上，插入 b[n],也就是 d[m][n] === d[m][n-1]+1
这三种情况都有可能，所以要取这个值的最小值
递归结束条件：我们观察到 "abc" => "" ，最小编辑距离为3,"" => "ac"，最小编辑距离为2，也就是说，
当其中一个字符串长度为0的时候，d为另一个字符串的长度。

代码实现如下：
```js
/**
 * 递归算法
 * @param {string} a
 * @param {string} b
 * @param {number} i 字符串 a 的长度
 * @param {number} j 字符串 b 的长度
 * @returns {number} 从 a → b 的最小编辑距离
 */
function recursion(a, b, i, j) {
    if (j === 0) {
        return i;
    } else if (i === 0) {
        return j;
    } else if (a[i - 1] === b [j - 1]) {
        return recursion(a, b, i - 1, j - 1);
    } else {
        let m1 = recursion(a, b, i - 1, j) + 1;
        let m2 = recursion(a, b, i, j - 1) + 1;
        let m3 = recursion(a, b, i - 1, j - 1) + 1;
        return Math.min(m1, m2, m3);
    }
}
```
这个递归实现的复杂度是多少呢？说实话，我并不知道，因为我只知道"两重循环的复杂度是平方"，但是对于这种递归，我无法从理论上推测其复杂度。
怎么办呢？我决定从实证角度求取答案。不过在此之前，我们先来看另一种算法实现。

# 动态规划
动态规划跟递归正好反过来，从小问题开始算起，不断推广到大问题，判断逻辑还是跟上面一样的。
要求得 d[1][1]，先判断 a[1]b[1]是否相等。
1. 如果 a[1] === a[1]，那么 d[1][1] 等于 d[0][0]，也就是0
2. 如果 a[1] !== b[1]，那么 d[1][1] 等于 d[0][1] 、d[1][0] 、d[0][0]中的最小值+1，也就是1
要接着用同样的方式求得 d[1][2]、d[1][3]、....、d[1][n]，
然后继续求得 d[2][1]、d[2][2]、....、d[2][n]，如此类推，一直到 d[m][n]
代码实现如下：
```js
/**
 * 动态规划算法
 * @param {string} a
 * @param {string} b
 * @returns {number} 从 a → b 的最小编辑距离
 */
function dynamicPlanning(a, b) {
    let lenA = a.length;
    let lenB = b.length;
    let d = [];
    d[0] = [];

    for (let j = 0; j <= lenB; j++) {
        d[0].push(j);
    }

    for (let i = 0; i <= lenA; i++) {
        if (d[i]) {
            d[i][0] = i;
        } else {
            d[i] = [];
            d[i][0] = i;
        }
    }

    for (let i = 1; i <= lenA; i++) {
        for (let j = 1; j <= lenB; j++) {
            if (a[i - 1] === b[j - 1]) {
                d[i][j] = d[i - 1][j - 1];
            } else {
                let m1 = d[i - 1][j] + 1;
                let m2 = d[i][j - 1] + 1;
                let m3 = d[i - 1][j - 1] + 1;
                d[i][j] = Math.min(m1, m2, m3);
            }
        }
    }

    return d[lenA][lenB];
}
```
那么，这两种实现哪一种更快呢？按照参考资料显示是动态规划，但是我不确信，理由刚刚我已经说过了，
对于复杂的程序，我找不到从理论上预测复杂度的方式。因此，我决定求助于实证。

# 实证
我使用了 jsperf 实际测量其运行时间，具体的 case 请参考这里：https://jsperf.com/edit-distance-test2/1
实际运行结果如下所示：
// 此处缺图
从图中我们可以看到：动态规划的时间复杂度确实远小于递归。然而，动态规划是如何做到这么快的呢？
从程序实现的角度看，应该是占用了更多的空间，因为程序运行的时候，需要维护一个 d[i][j] 的矩阵，也就是"以空间换时间"，
但是，具体这两种实现的空间复杂度是多少呢？我还不知道，而且我也找不到能实际衡量空间复杂度的工具。
